<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Euler's Method Plot</title>
    <style>
        body {
            font-family: Arial, sans-serif;

            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: auto;

            --bg-color: #f0f0f0;
            --text-color: #333;

            background-color: var(--bg-color);
        }

        canvas {
            border: 1px solid var(--text-color);
        }

        textarea {
            width: 100%;
            height: 100px;
        }

        input {
            margin: 5px;
        }

        input[type="number"] {
            width: 50px;
        }

        input[type="range"] {
            width: 100px;
        }
    </style>
</head>

<body>

    <h1>Euler's Method Plot</h1>

    <canvas id="canvas"></canvas>

    <div onchange="onInputChange()">

        <div style="display: flex; flex-direction: row; gap: 1em; justify-content: space-evenly;">
            <div>
                <h4>View</h4>
            </div>
            <div>
                x <input type="number" id="minX" value="-10">
                &ndash; <input type="number" id="maxX" value="10">
                <br>
                y <input type="number" id="minY" value="-10">
                &ndash; <input type="number" id="maxY" value="10">
                <br>
                <label for="showField">Show Field:</label>
                <input type="checkbox" id="showField" checked>
            </div>
        </div>

        <hr>

        <label for="x0">x0:</label>
        <input type="number" id="x0" value="8">

        <label for="y0">y0:</label>
        <input type="number" id="y0" value="0">

        <label for="h">h:</label>
        <input type="number" id="h" value="-0.002">

        <br>

        <label for="steps">Steps:</label>
        <input type="number" id="steps" value="5000">
        <input type="range" id="_steps" min="1" max="5000" value="5000" oninput="setStepsFromSlider()">

        <br>

        <!-- k slider -->
        <label for="k">k:</label>
        <input type="range" id="k" min="0" max="1" value="0.9" step="0.01" oninput="onInputChange()">

        <br>

        <textarea id="G">y/x + sqrt(1+(y/x)**2) * k</textarea>
    </div>

    <script>
        // Function to set up the canvas
        function setupCanvas( width, height ) {
            canvas.width = width
            canvas.height = height
            return canvas.getContext( '2d' )
        }

        const ctx = setupCanvas( 800, 600 )

        function isLarge( x ) {
            return Math.abs( x ) > 1e6
        }

        function normalizeLarge( x, y ) {
            let len = Math.sqrt( x * x + y * y )
            let scale = 1e6 / len
            return { x: x * scale, y: y * scale }
        }

        // Euler's method implementation
        function eulerMethod( g, x0, y0, h, steps ) {
            const points = []
            let x = x0
            let y = y0
            points.push( { x, y } )
            for ( let i = 0; i < steps; i++ ) {
                y += h * g( x, y )
                x += h

                if ( isNaN( x ) || isNaN( y ) )
                    break

                if ( isLarge( x ) || isLarge( y ) ) {
                    points.push( normalizeLarge( x, y ) )
                } else {
                    points.push( { x, y } )
                }


            }
            return points
        }

        // Function to plot the points
        function plotPoints( ctx, points, width, height ) {
            ctx.beginPath()
            ctx.moveTo( points[ 0 ].x, points[ 0 ].y )
            points.forEach( point => {
                ctx.lineTo( point.x, point.y )
            } )
            ctx.strokeStyle = 'red'
            ctx.lineWidth = 2
            ctx.stroke()
        }

        function getViewBounds() {
            const xMin = parseFloat( document.getElementById( 'minX' ).value )
            const xMax = parseFloat( document.getElementById( 'maxX' ).value )
            const yMin = parseFloat( document.getElementById( 'minY' ).value )
            const yMax = parseFloat( document.getElementById( 'maxY' ).value )

            return { xMin, xMax, yMin, yMax }
        }

        function mapToCanvas( x, y, bounds, width, height ) {
            const x0 = bounds.xMin
            const x1 = bounds.xMax
            const y0 = bounds.yMin
            const y1 = bounds.yMax

            const xCanvas = ( x - x0 ) / ( x1 - x0 ) * width
            const yCanvas = height - ( y - y0 ) / ( y1 - y0 ) * height

            return { x: xCanvas, y: yCanvas }
        }

        function plotGrid( bounds, width, height ) {
            const xMin = bounds.xMin
            const xMax = bounds.xMax
            const yMin = bounds.yMin
            const yMax = bounds.yMax

            const xStep = ( xMax - xMin ) / 10
            const yStep = ( yMax - yMin ) / 10

            ctx.strokeStyle = 'black'

            for ( let x = xMin; x <= xMax; x += xStep ) {
                const xCanvas = mapToCanvas( x, 0, bounds, width, height ).x
                ctx.beginPath()
                ctx.moveTo( xCanvas, 0 )
                ctx.lineTo( xCanvas, height )
                ctx.lineWidth = ( x == 0 ) ? 2 : 1
                ctx.stroke()
            }

            for ( let y = yMin; y <= yMax; y += yStep ) {
                const yCanvas = mapToCanvas( 0, y, bounds, width, height ).y
                ctx.beginPath()
                ctx.moveTo( 0, yCanvas )
                ctx.lineTo( width, yCanvas )
                ctx.lineWidth = ( y == 0 ) ? 2 : 1
                ctx.stroke()
            }
        }

        function drawCircle( ctx, p, r ) {
            ctx.beginPath()
            ctx.arc( p.x, p.y, r, 0, 2 * Math.PI )
            ctx.fill()
        }

        function setStepsFromSlider() {
            const steps = parseInt( document.getElementById( '_steps' ).value )
            document.getElementById( 'steps' ).value = steps
            onInputChange()
        }

        function plotSlopeField( g, bounds, width, height ) {
            const xMin = bounds.xMin
            const xMax = bounds.xMax
            const yMin = bounds.yMin
            const yMax = bounds.yMax

            const xStep = ( xMax - xMin ) / 10
            const yStep = ( yMax - yMin ) / 10

            for ( let x = xMin; x <= xMax; x += xStep ) {
                for ( let y = yMin; y <= yMax; y += yStep ) {
                    const slope = g( x, y )
                    const p = mapToCanvas( x - 0.1, y - 0.1 * slope, bounds, width, height )
                    const q = mapToCanvas( x + 0.1, y + 0.1 * slope, bounds, width, height )
                    ctx.beginPath()
                    ctx.moveTo( p.x, p.y )
                    ctx.lineTo( q.x, q.y )
                    ctx.stroke()
                }
            }

        }

        function onInputChange() {
            const x0 = parseFloat( document.getElementById( 'x0' ).value )
            const y0 = parseFloat( document.getElementById( 'y0' ).value )
            const h = parseFloat( document.getElementById( 'h' ).value )
            const steps = parseInt( document.getElementById( 'steps' ).value )
            const k = parseFloat( document.getElementById( 'k' ).value )

            const prolog = `
                const k = ${ k };
                ${ Object.getOwnPropertyNames( Math ).map( key => `const ${ key } = Math.${ key };` ).join( '\n' ) }
            `
            let code = document.getElementById( 'G' ).value
            if ( code.split( "\n" ).length == 1 && !code.includes( "return" ) )
                code = `return ${ code }`
            const G = new Function( 'x', 'y', prolog + code )

            const points = eulerMethod( G, x0, y0, h, steps )
            const bounds = getViewBounds()

            // Update slider value
            document.getElementById( '_steps' ).value = steps

            const W = ctx.canvas.width
            const H = ctx.canvas.height

            const canvasPoints = points.map( point => mapToCanvas( point.x, point.y, bounds, W, H ) )

            ctx.clearRect( 0, 0, W, H )

            plotGrid( bounds, W, H )

            if ( document.getElementById( 'showField' ).checked ) {
                ctx.lineWidth = 2
                ctx.strokeStyle = 'blue'
                plotSlopeField( G, bounds, W, H )
            }

            plotPoints( ctx, canvasPoints, W, H )

            ctx.fillStyle = 'red'
            drawCircle( ctx, canvasPoints[ 0 ], 4 )
            drawCircle( ctx, canvasPoints[ canvasPoints.length - 1 ], 3 )
        }

        onInputChange()

    </script>
</body>

</html>