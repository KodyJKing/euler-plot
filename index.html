<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Euler's Method Plot</title>
    <style>
        body {
            font-family: Arial, sans-serif;

            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: auto;

            --bg-color: #f0f0f0;
            --text-color: #333;

            background-color: var(--bg-color);
        }

        canvas {
            border: 1px solid var(--text-color);
            cursor: grab;
        }

        textarea {
            width: 100%;
            height: 100px;
        }

        input {
            margin: 5px;
        }

        input[type="number"] {
            width: 100px;
        }

        input[type="range"] {
            width: 100px;
        }
    </style>
</head>

<body>

    <h1>Euler's Method Plot</h1>

    <canvas id="canvas"></canvas>

    <div onchange="updatePlot()">

        <!-- <div style="display: flex; flex-direction: row; gap: 1em; justify-content: space-evenly;">
            <div>
                <h4>View</h4>
            </div>
        </div> -->
        <div>
            <label for="showField">Slope Field:</label>
            <input type="checkbox" id="showField" checked>
            <label for="density">Density:</label>
            <input type="number" id="density" value="15">
            <label for="normalizeSlope">Normalize:</label>
            <input type="checkbox" id="normalizeSlope" checked>
            <br>
            x <input type="number" id="minX" value="-10">
            &ndash; <input type="number" id="maxX" value="10">
            <br>
            y <input type="number" id="minY" value="-10">
            &ndash; <input type="number" id="maxY" value="10">

        </div>

        <hr>

        <label for="x0">x0:</label>
        <input type="number" id="x0" value="8">

        <label for="y0">y0:</label>
        <input type="number" id="y0" value="0">

        <label for="h">h:</label>
        <input type="number" id="h" value="-0.002">

        <br>

        <label for="steps">Steps:</label>
        <input type="number" id="steps" value="5000">
        <input type="range" id="_steps" min="1" max="5000" value="5000" oninput="setStepsFromSlider()">

        <br>

        <!-- k slider -->
        <label for="k">k:</label>
        <input type="range" id="k" min="0" max="1" value="0.9" step="0.01" oninput="updatePlot()">

        <br>

        <textarea id="G">y/x + sqrt(1+(y/x)**2) * k</textarea>
    </div>

    <script>

        function setupMouseNavHandlers() {
            let isDragging = false
            let prevX = 0
            let prevY = 0

            canvas.addEventListener( 'wheel', e => {
                const xMin = parseFloat( document.getElementById( 'minX' ).value )
                const xMax = parseFloat( document.getElementById( 'maxX' ).value )
                const yMin = parseFloat( document.getElementById( 'minY' ).value )
                const yMax = parseFloat( document.getElementById( 'maxY' ).value )

                const xRange = xMax - xMin
                const yRange = yMax - yMin

                const scaleX = xRange / canvas.width
                const scaleY = yRange / canvas.height

                const x = e.offsetX * scaleX + xMin
                const y = yMax - e.offsetY * scaleY

                const factor = e.deltaY > 0 ? 1.1 : 0.9

                document.getElementById( 'minX' ).value = x - ( x - xMin ) * factor
                document.getElementById( 'maxX' ).value = x + ( xMax - x ) * factor
                document.getElementById( 'minY' ).value = y - ( y - yMin ) * factor
                document.getElementById( 'maxY' ).value = y + ( yMax - y ) * factor

                updatePlot()
            } )

            canvas.addEventListener( 'mousedown', e => {
                isDragging = true
                prevX = e.offsetX
                prevY = e.offsetY
            } )

            canvas.addEventListener( 'mouseup', e => {
                isDragging = false
            } )

            canvas.addEventListener( 'mousemove', e => {
                if ( isDragging ) {
                    const dx = e.offsetX - prevX
                    const dy = e.offsetY - prevY

                    const xMin = parseFloat( document.getElementById( 'minX' ).value )
                    const xMax = parseFloat( document.getElementById( 'maxX' ).value )
                    const yMin = parseFloat( document.getElementById( 'minY' ).value )
                    const yMax = parseFloat( document.getElementById( 'maxY' ).value )

                    const xRange = xMax - xMin
                    const yRange = yMax - yMin

                    const scaleX = xRange / canvas.width
                    const scaleY = yRange / canvas.height

                    document.getElementById( 'minX' ).value = xMin - dx * scaleX
                    document.getElementById( 'maxX' ).value = xMax - dx * scaleX
                    document.getElementById( 'minY' ).value = yMin + dy * scaleY
                    document.getElementById( 'maxY' ).value = yMax + dy * scaleY

                    updatePlot()

                    prevX = e.offsetX
                    prevY = e.offsetY
                }
            } )
        }
        setupMouseNavHandlers()

        function isLarge( x ) {
            return Math.abs( x ) > 1e6
        }

        function normalizeLarge( x, y ) {
            let len = Math.sqrt( x * x + y * y )
            let scale = 1e6 / len
            return { x: x * scale, y: y * scale }
        }

        // Euler's method implementation
        function eulerMethod( g, x0, y0, h, steps ) {
            const points = []
            let x = x0
            let y = y0
            points.push( { x, y } )
            for ( let i = 0; i < steps; i++ ) {
                y += h * g( x, y )
                x += h

                if ( isNaN( x ) || isNaN( y ) )
                    break

                if ( isLarge( x ) || isLarge( y ) ) {
                    points.push( normalizeLarge( x, y ) )
                } else {
                    points.push( { x, y } )
                }


            }
            return points
        }

        function mapToCanvas( x, y, bounds, width, height ) {
            const x0 = bounds.xMin
            const x1 = bounds.xMax
            const y0 = bounds.yMin
            const y1 = bounds.yMax

            const xCanvas = ( x - x0 ) / ( x1 - x0 ) * width
            const yCanvas = height - ( y - y0 ) / ( y1 - y0 ) * height

            return { x: xCanvas, y: yCanvas }
        }

        function plotPoints( ctx, points, width, height ) {
            ctx.beginPath()
            ctx.moveTo( points[ 0 ].x, points[ 0 ].y )
            points.forEach( point => {
                ctx.lineTo( point.x, point.y )
            } )
            ctx.stroke()
        }

        function drawCircle( ctx, p, r ) {
            ctx.beginPath()
            ctx.arc( p.x, p.y, r, 0, 2 * Math.PI )
            ctx.fill()
        }

        function drawAxes( ctx, bounds, width, height ) {
            const origin = mapToCanvas( 0, 0, bounds, width, height )

            ctx.beginPath()
            ctx.moveTo( origin.x, 0 )
            ctx.lineTo( origin.x, height )
            ctx.stroke()

            ctx.beginPath()
            ctx.moveTo( 0, origin.y )
            ctx.lineTo( width, origin.y )
            ctx.stroke()

            drawCircle( ctx, origin, 2 )
        }

        function plotSlopeField( ctx, g, bounds, width, height, density = 15 ) {
            const xMin = bounds.xMin
            const xMax = bounds.xMax
            const yMin = bounds.yMin
            const yMax = bounds.yMax

            const xStep = ( xMax - xMin ) / density
            const yStep = ( yMax - yMin ) / density

            const normalizeSlope = document.getElementById( 'normalizeSlope' ).checked

            for ( let x = xMin; x <= xMax; x += xStep ) {
                for ( let y = yMin; y <= yMax; y += yStep ) {
                    const slope = g( x, y )

                    let dx = 1
                    let dy = 1 * slope
                    if ( normalizeSlope ) {
                        const len = Math.sqrt( dx * dx + dy * dy )

                        const range = 5
                        const adjLen = Math.tanh( len / range ) * range

                        dx *= adjLen / len
                        dy *= adjLen / len
                    }
                    dx *= 0.1
                    dy *= 0.1

                    const p = mapToCanvas( x - dx, y - dy, bounds, width, height )
                    const q = mapToCanvas( x + dx, y + dy, bounds, width, height )
                    ctx.beginPath()
                    ctx.moveTo( p.x, p.y )
                    ctx.lineTo( q.x, q.y )
                    ctx.stroke()
                }
            }

        }

        function setStepsFromSlider() {
            const steps = parseInt( document.getElementById( '_steps' ).value )
            document.getElementById( 'steps' ).value = steps
            updatePlot()
        }

        function updatePlot() {
            const W = 800
            const H = 600

            canvas.width = W
            canvas.height = H

            const ctx = canvas.getContext( '2d' )

            const x0 = parseFloat( document.getElementById( 'x0' ).value )
            const y0 = parseFloat( document.getElementById( 'y0' ).value )
            const h = parseFloat( document.getElementById( 'h' ).value )
            const steps = parseInt( document.getElementById( 'steps' ).value )
            const k = parseFloat( document.getElementById( 'k' ).value )

            const G = ( () => {
                const prolog = `
                    const k = ${ k };
                    ${ Object.getOwnPropertyNames( Math ).map( key => `const ${ key } = Math.${ key };` ).join( '\n' ) }
                `
                let code = document.getElementById( 'G' ).value
                if ( code.split( "\n" ).length == 1 && !code.includes( "return" ) )
                    code = `return ${ code }`
                return new Function( 'x', 'y', prolog + code )
            } )()

            const points = eulerMethod( G, x0, y0, h, steps )

            const bounds = ( () => {
                const xMin = parseFloat( document.getElementById( 'minX' ).value )
                const xMax = parseFloat( document.getElementById( 'maxX' ).value )
                const yMin = parseFloat( document.getElementById( 'minY' ).value )
                const yMax = parseFloat( document.getElementById( 'maxY' ).value )
                return { xMin, xMax, yMin, yMax }
            } )()

            // Update slider value
            document.getElementById( '_steps' ).value = steps

            const canvasPoints = points.map( point => mapToCanvas( point.x, point.y, bounds, W, H ) )

            ctx.clearRect( 0, 0, W, H )

            ctx.strokeStyle = 'black'
            ctx.lineWidth = 1
            ctx.fillStyle = 'black'
            drawAxes( ctx, bounds, W, H )

            if ( document.getElementById( 'showField' ).checked ) {
                ctx.lineWidth = 2
                ctx.strokeStyle = 'blue'
                plotSlopeField( ctx, G, bounds, W, H, parseInt( document.getElementById( 'density' ).value ) )
            }

            ctx.strokeStyle = 'red'
            ctx.lineWidth = 2
            plotPoints( ctx, canvasPoints, W, H )

            ctx.fillStyle = 'red'
            drawCircle( ctx, canvasPoints[ 0 ], 4 )
            drawCircle( ctx, canvasPoints[ canvasPoints.length - 1 ], 3 )
        }

        updatePlot()

    </script>
</body>

</html>